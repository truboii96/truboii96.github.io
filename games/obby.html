<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Roblox-Style Obby Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Click to lock pointer and play.<br>
        WASD: Move<br>
        Space: Jump<br>
        Esc: Unlock pointer
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 0, 500);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 2; // Player height

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Pointer lock controls
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        // Lock pointer on click
        document.addEventListener('click', () => {
            controls.lock();
        });

        // Unlock on Esc (handled by browser, but we can listen)
        controls.addEventListener('unlock', () => {
            console.log('Pointer unlocked');
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Platforms for obby (simple level)
        const platformMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });

        // Start platform
        const startPlatform = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), platformMaterial);
        startPlatform.position.set(0, 0.5, 0);
        scene.add(startPlatform);

        // Jump platform 1
        const platform1 = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 5), platformMaterial);
        platform1.position.set(0, 1.5, 15);
        scene.add(platform1);

        // Jump platform 2 (higher)
        const platform2 = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 5), platformMaterial);
        platform2.position.set(10, 3.5, 20);
        scene.add(platform2);

        // Obstacle (spinning blade simulation with a box)
        const obstacle = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 2), new THREE.MeshLambertMaterial({ color: 0xFF0000 }));
        obstacle.position.set(-10, 5, 30);
        scene.add(obstacle);

        // End platform
        const endPlatform = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), new THREE.MeshLambertMaterial({ color: 0x00FF00 }));
        endPlatform.position.set(0, 0.5, 50);
        scene.add(endPlatform);

        // Collect all collidable objects
        const collidables = [ground, startPlatform, platform1, platform2, endPlatform, obstacle];

        // Player physics
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        const gravity = -0.005;
        const jumpVelocity = 0.15;
        const moveSpeed = 0.1;

        // Raycaster for ground detection
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 2.1); // Slightly more than player height

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    if (canJump) {
                        velocity.y = jumpVelocity;
                        canJump = false;
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Collision detection function
        function checkCollision(position) {
            for (let obj of collidables) {
                const box = new THREE.Box3().setFromObject(obj);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(position.x - 1, position.y - 2, position.z - 1),
                    new THREE.Vector3(position.x + 1, position.y, position.z + 1)
                );
                if (box.intersectsBox(playerBox)) {
                    return true;
                }
            }
            return false;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                // Movement
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z = direction.z * moveSpeed;
                else velocity.z = 0;
                if (moveLeft || moveRight) velocity.x = direction.x * moveSpeed;
                else velocity.x = 0;

                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);

                // Gravity and jumping
                velocity.y += gravity;

                camera.position.y += velocity.y;

                // Ground collision
                raycaster.ray.origin.copy(camera.position);
                const intersections = raycaster.intersectObjects(collidables);
                if (intersections.length > 0) {
                    const distance = intersections[0].distance;
                    if (distance < 2) { // Player height
                        velocity.y = 0;
                        camera.position.y = intersections[0].point.y + 2;
                        canJump = true;
                    }
                }

                // Side collisions (simple prevention)
                const proposedPosition = camera.position.clone();
                if (checkCollision(proposedPosition)) {
                    // Revert movement if colliding
                    camera.position.sub(velocity);
                }

                // Obstacle rotation (simple animation)
                obstacle.rotation.y += 0.05;
            }

            // Check for win (reach end platform)
            if (camera.position.z > 45 && camera.position.z < 55 && Math.abs(camera.position.x) < 5 && camera.position.y < 3) {
                alert('You win! Reached the end.');
                controls.unlock();
            }

            // Death if fall below
            if (camera.position.y < -10) {
                camera.position.set(0, 2, 0);
                velocity.set(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
